---
# Initialise a the very first host in a brand-new vault cluster, leaving it in
# an unsealed state.
#
# Does nothing if at least one host is already initialised.

- name: Ensure Vault servers started
  systemd:
    name: vault
    state: started

# NB: We retry with a generous delay here in case we're accessing Vault via
# some kind of proxy which might not immediately notice that the server has come
# up.
- name: Ensure vault server reachable and get cluster membership statuses
  uri:
    # vault status
    url: "{{ ansible_vault_public_url }}/v1/sys/seal-status"
    ca_path: "{{ ansible_vault_ca_path | default(omit) }}"
  retries: 5
  delay: 5
  until: vault_status.status == 200  # i.e. connection successful
  register: vault_status

- name: Check if Vault servers are initialised
  set_fact:
    vault_initialised: "{{ vault_status.json.initialized }}"

- name: Count uninitialised servers
  set_fact:
    num_initialised: |-
      {{
        groups[ansible_vault_cluster_ansible_group_name]
          | map("extract", hostvars)
          | selectattr("vault_initialised", "defined")
          | selectattr("vault_initialised", "true")
          | length
      }}
    num_uninitialised: |-
      {{
        groups[ansible_vault_cluster_ansible_group_name]
          | map('extract', hostvars)
          | selectattr("vault_initialised", "defined")
          | selectattr("vault_initialised", "false")
          | length
      }}
  run_once: true

- name: Initialise a single member of the cluster
  when: num_initialised == 0
  any_errors_fatal: true
  block:
    # Sanity check to prevent accidentally initialising a second cluster when
    # the user, e.g., limits the playbook to just a single new (uninitialised)
    # node.
    - name: Sanity check that *all* servers are uninitialised
      run_once: true
      assert:
        that: |-
          ansible_vault_skip_cluster_init_sanity_check or
          num_uninitialised == (groups[ansible_vault_cluster_ansible_group_name] | length)
        quiet: true
        fail_msg: "All cluster members must be up (and uninitialised)."
    
    - name: Sanity check public keys
      import_tasks: check_public_keys.yml
    
    - name: Initialise a single node
      run_once: true
      block:
        # NB: We initialise with a temporary singular, unencrypted unseal key so
        # that we can use that key to unseal the vault then immediately revoke the
        # root token generated during initialisation. We do this because later
        # parts of this playbook will assume that no root tokens exist and we
        # can't request initialisation without creating a root token.
        - name: Initialise first cluster member with temporary unseal key
          uri:
            # vault operator init
            url: "{{ ansible_vault_public_url }}/v1/sys/init"
            method: POST
            body_format: json
            body:
              secret_shares: 1
              secret_threshold: 1
            ca_path: "{{ ansible_vault_ca_path | default(omit) }}"
          changed_when: true
          register: vault_init
        
        - name: Unseal vault with temporary unseal key
          uri:
            # vault operator unseal
            url: "{{ ansible_vault_public_url }}/v1/sys/unseal"
            method: POST
            body_format: json
            body:
              key: "{{ vault_init.json.keys_base64[0] }}"
            ca_path: "{{ ansible_vault_ca_path | default(omit) }}"
          changed_when: true
          register: vault_unseal
          failed_when: vault_unseal.json.sealed
        
        - name: Revoke the root token created during initialisation
          uri:
            # vault token revoke
            url: "{{ ansible_vault_public_url }}/v1/auth/token/revoke-self"
            method: POST
            headers:
              "X-Vault-Token": "{{ vault_init.json.root_token }}"
            status_code: [200, 204]  # OK or No Content
            ca_path: "{{ ansible_vault_ca_path | default(omit) }}"
          changed_when: true
        
        # NB: During the initial keying we do not verify the key is readable.
        # This saves bothering other keyholders whilst the database is still
        # empty. Since a later step in this playbook will involve using the
        # unseal keys to unseal other cluster nodes and obtain root tokens,
        # we'll be using (and implicitly verifying) these new unseal keys
        # before we put anything of value in the vault!
        - name: Begin rekeying with PGP-encrypted keys
          uri:
            # vault operator rekey -init ...
            url: "{{ ansible_vault_public_url }}/v1/sys/rekey/init"
            method: POST
            body_format: json
            body:
              secret_threshold: "{{ ansible_vault_unseal_key_threshold }}"
              secret_shares: "{{ pgp_keys | length }}"
              pgp_keys: "{{ pgp_keys }}"
              require_verification: false
            ca_path: "{{ ansible_vault_ca_path | default(omit) }}"
          changed_when: true
          register: vault_rekey_init
        
        - name: Supply temporary unseal key
          uri:
            # vault operator rekey ...
            url: "{{ ansible_vault_public_url }}/v1/sys/rekey/update"
            method: POST
            body_format: json
            body:
              nonce: "{{ vault_rekey_init.json.nonce }}"
              key: "{{ vault_init.json.keys_base64[0] }}"
            ca_path: "{{ ansible_vault_ca_path | default(omit) }}"
          changed_when: true
          failed_when: not vault_rekey_update.json.complete
          register: vault_rekey_update
        
        - name: Create encrypted unseal key bundle
          import_tasks: save_encrypted_unseal_keys.yml
          vars:
            encrypted_unseal_keys_base64: "{{ vault_rekey_update.json.keys_base64 }}"
